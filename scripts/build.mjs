import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

// Windows-safe repo root resolution (avoids E:\\E:\\... issues)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..");

// Shared inputs
const masterPath = path.join(repoRoot, "data", "master", "master-matrix.json");
const decisionDir = path.join(repoRoot, "data", "decision");

// Output directory for browser bundles
const outDir = path.join(repoRoot, "web", "generated");
fs.mkdirSync(outDir, { recursive: true });

// Load master matrix once
const master = JSON.parse(fs.readFileSync(masterPath, "utf8"));
const pkg = JSON.parse(fs.readFileSync(path.join(repoRoot, "package.json"), "utf8"));
const appVersion = pkg.version || "0.0.0";
const buildId = "2026.01.08.01";


function readJson(p) {
  return JSON.parse(fs.readFileSync(p, "utf8"));
}

function makeProvider(providerId, displayName) {
  const serviceCategories = {};
  for (const row of (master.rows || [])) {
    const cat = row.domain;
    const services = (row.providers?.[providerId] || []).map((name) => ({
      id: (providerId + "_" + name)
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "_")
        .replace(/^_+|_+$/g, ""),
      name,
      category: cat
    }));
    serviceCategories[cat] = services;
  }
  return { id: providerId, displayName, serviceCategories };
}

// 1) catalog.generated.js (window.CDK + window.ATK_CATALOG)
const catalog = {
  version: master.catalog_version,
  generatedAt: new Date().toISOString(),
  providers: {
    aws: makeProvider("aws", "AWS"),
    azure: makeProvider("azure", "Azure"),
    gcp: makeProvider("gcp", "Google Cloud"),
    oci: makeProvider("oci", "Oracle Cloud")
  }
};

const catalogJs = `// Auto-generated by scripts/build.mjs
(function(){
  window.CDK = window.CDK || { providers: {}, tools: {} };
  window.CDK.providers = window.CDK.providers || {};
  const catalog = ${JSON.stringify(catalog, null, 2)};
  window.ATK_CATALOG = catalog;
  window.CDK.providers.aws = catalog.providers.aws;
  window.CDK.providers.azure = catalog.providers.azure;
  window.CDK.providers.gcp = catalog.providers.gcp;
  window.CDK.providers.oci = catalog.providers.oci;
})();`;

fs.writeFileSync(path.join(outDir, "catalog.generated.js"), catalogJs, "utf8");

// 2) version.generated.js
fs.writeFileSync(
  path.join(outDir, "version.generated.js"),
  `window.ATK_VERSION=${JSON.stringify({
    app_version: appVersion,
    build_id: buildId,
    data_catalog_version: master.catalog_version,
    generatedAt: catalog.generatedAt
  })};
`,
  "utf8"
);

// 3) decision.generated.js (capabilities + patterns + rules)
const decision = {
  generatedAt: new Date().toISOString(),
  capabilities: readJson(path.join(decisionDir, "capabilities.json")),
  patterns: readJson(path.join(decisionDir, "patterns.json")),
  rules: readJson(path.join(decisionDir, "rules.json"))
};

const decisionJs = `// Auto-generated by scripts/build.mjs
(function(){
  window.ATK_DECISION = ${JSON.stringify(decision, null, 2)};
})();`;

fs.writeFileSync(path.join(outDir, "decision.generated.js"), decisionJs, "utf8");

// 4) capability-map.generated.js (capability_id -> provider services)
const capMap = {};
for (const row of (master.rows || [])) {
  const cid = row.capability_id;
  if (!cid) continue;

  capMap[cid] = {
    domain: row.domain || "",
    capability_name: row.capability_name || "",
    used_for: row.used_for || "",
    aws: (row.providers?.aws || []),
    azure: (row.providers?.azure || []),
    gcp: (row.providers?.gcp || []),
    oci: (row.providers?.oci || [])
  };
}

const capMapJs = `// Auto-generated by scripts/build.mjs
(function(){
  window.ATK_CAP_MAP = ${JSON.stringify(capMap, null, 2)};
})();`;

fs.writeFileSync(path.join(outDir, "capability-map.generated.js"), capMapJs, "utf8");

console.log("âœ… Build complete:", outDir);
